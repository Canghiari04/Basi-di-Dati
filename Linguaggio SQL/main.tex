\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}

\titleformat{\section} 
{\LARGE\bfseries}{\thesection}{1em}{}

\titleformat{\subsection} 
{\Large\bfseries}{\thesection}{1em}{}

\begin{document}

\pagestyle{empty}

\section*{Linguaggio SQL} 
\large
Il \textit{modello relazionale} definisce i \textbf{concetti generali} e i \textbf{vincoli} per modellare e strutturare i dati di una certa applicazione.\ Tuttavia, tramite lo studio del solo modello relazionale, non sarebbe possibile costruire lo \textit{schema} del DB e manipolare le \textit{istanze} associate.
Questa richiesta è soddisfatta tramite l'impiego di \textbf{linguaggi data-oriented}, i quali possono essere suddivisi in tre macro-categorie rispetto alla compatibilità o meno con un RDBMS, ossia:
\begin{enumerate}
    \renewcommand{\labelenumi}{-} 
    \itemsep0em
    \item \textit{Linguaggi rappresentativi tramite interfacce grafiche}
    \item \textit{Linguaggi basati su proprietà algebrico/logiche}
    \item \textit{Linguaggio SQL}
\end{enumerate}
Tra i tre citati senza alcun dubbio, in associazione ad un modello relazionale, \textbf{SQL} rappresenta il \textit{linguaggio di riferimento}.
\subsection*{Introduzione}
\large
\textbf{SQL} è un linguaggio per la costruzione di modelli relazionali.\ Caratterizzato dagli stessi concetti generali su cui si fonda un qualsiasi \textit{modello relazionale}, ma pone alcune differenze, in riferimento:
\begin{enumerate}
    \renewcommand{\labelenumi}{-} 
    \itemsep0em
    \item La denominazione data alle \textit{relazioni} in questo contesto prende il nome di \textbf{tabelle}
    \item Il risultato di un'operazione sui dati può restituire una tabella con \textbf{righe duplicate}
    \item Il sistema dei \textbf{vincoli} è più \textbf{espressivo} o \textbf{informativo}
    \item Il vincolo di \textbf{integrità referenziale}, ossia in relazione alla \textit{foreign key}, è \textbf{meno stringente}.\ Si ricordi la regola generale, la quale richiede che tra tabella referenziante e referenziata, le colonne che compongano la referenza siano corrispettivamente qualsiasi dominio per la prima relazione, ma che ricada esattamente sulla chiave primaria della seconda relazione; ciò rispetto ad una manipolazione di dati potrebbe aumentare di molto la complessità gestionale.
\end{enumerate}
La grande diffusione di SQL è dovuta da un duro lavoro di standardizzazione che ha portato ad innumerevoli versioni e modifiche del paradigma, impegno portato avanti sin dagli anni ottanta. Tuttavia ancora oggi, differenti pubblicazioni sono ancora lontane dall'essere comunemente adottate. Per questa ragione, spesso si fa riferimento a \textit{SQL-2}, il quale pone sottili caratteristiche legate alla sintattica del linguaggio.\vspace{14pt}\\
SQL non è solamente adottato per esprimere interrogazioni rispetto alla base di dati di riferimento. Contiene infatti al suo interno funzionalità dedicate al \textbf{DDL}, \textit{Data Definition Language}, il quale permette la definizione dello \textit{schema} di una base di dati, e al \textbf{DML}, \textit{Data Manipulation Language}, ossia un insieme di comandi per la modifica e l'interrogazione delle istanze di una base di dati.

\subsection*{Data Definition Language}
\large
La prima parte trattata riguarda le funzionalità adoperate per la definizione dello \textit{schema} della base di dati. Tramite il costrutto \textit{create database}, è possibile costruire uno \textbf{schema} di una base di dati, da non confondere con lo \textit{schema} di una tabella, ossia dall'insieme posto dal nome della relazione e degli attributi associati. I comandi dedicati sono:\vspace*{7pt}
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create database [if not exists] nameDataBase}
\end{itemize}
implementato per la creazione del collettore successivo di \textit{tabelle}, \textit{viste} e \textit{interrogazioni} alle istanze di riferimento, e di seguito è riportato il corrispondente comando per l'eliminazione del database:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{drop database [if exists] nameDataBase}
\end{itemize}
si osserva come in entrambe le funzioni siano descritti comportamenti \textit{opzionali}, dovuti dall'uso della parentesi quadrate \textit{[if not exists]} e \textit{[if exists]}, le quali permettono di verificare, in questo contesto, dell'esistenza o meno del DB indicato nella nomenclatura.\vspace*{14pt}\\
Tramite il costrutto \textit{create table}, è possibile costruire una \textbf{tabella} all'interno dello \textit{schema} del DB. Il comando dedicato è:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create table nameTable (}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=2cm]
    \itemsep0em
    \item \textit{nameAttribute1 Domain [ValDefault][Constraint]} 
    \item \textit{nameAttribute2 Domain [ValDefault][Constraint]}
    \item \textit{...} 
\end{itemize}
\begin{itemize}[label={ }, leftmargin=1cm] 
    \item \textit{);}
\end{itemize}
nuovamente, tutto ciò che è circondato da parentesi quadrate indica un comportamento opzionale, ad eccezione del nome e del dominio dell'attributo specifico. In questo esempio la denominazione \textit{[ValDefault]} stabilisce quale sia la variabile di default associata all'istanza immessa qualora non sia specificato il valore, mentre \textit{[Constraint]} stabilisce un vincolo al quale un qualsiasi record immesso dovrà sottostare, di seguito verranno riportati i \textit{vincoli} principali.
\subsection*{Domini elementari}
\large
In SQL possono essere associati differenti \textbf{domini elementari} agli attributi di uno schema; \textit{schema} inteso a livello di tabella, per cui l'insieme dettato dal nominativo della relazione e dal nome degli attributi.
\textit{Character}\\Il dominio \textit{character} permette di rappresentare singoli caratteri oppure stringhe. La lunghezza di una stringa può essere sia fissa che variabile, nonostante in entrambi casi occorra specificare la lunghezza massima. La sintassi è:
\begin{itemize}[label={ }, leftmargin=1cm] 
    \item \textit{character [varying] [(Length)] [character set Language]}
\end{itemize}
quindi qualora si voglia inserire una stringa di 20 caratteri occorre specificare \textit{character (20)}, oppure in relazione ad una stringa con un massimo di 1000 caratteri, adottando uno specifico alfabeto occorre indicare \textit{character varying (1000) character set Greek}. Se la lunghezza non è specificata, il dominio dell'attributo indica un unico carattere. SQL ammette anche delle varianti compatte, spesso più utilizzate rispetto alle prime citate, le quali rispettivamente sono \textit{char} e \textit{varchar}, per stabilire una dimensione fissa piuttosto che una dimensione variabile.\vspace*{14pt}\\
\textit{Tipi numerici esatti}\\Questa famiglia consente di rappresentare valori esatti, interi o con una parte decimale di lunghezza prefissata. SQL mette a disposizione differenti soluzioni, quali:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{numeric [(Precision [, Scale])]}
    \item \textit{decimal [(Precision [, Scale])]}
    \item \textit{integer}
    \item \textit{smallint}
\end{itemize}
I domini \textit{numeric} e \textit{decimal} rappresentano numeri in base \textit{decimale}. Il parametro \textit{Precision} indica l'accurattezza del numero, mentre \textit{Scale} indica quante cifre sono dedicate alla parte frazionaria.
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{numeric (4, 2) : Intervallo[-99.99 : 99.99]} 
\end{itemize}
Nei casi in cui non sia zona di interesse la rappresentazione della parte frazionaria, allora diventa possibile usare i domini predefiniti \textit{int} e \textit{smallint}. Rispetto a questi ultimi due formati è possibile combinare il campo \textit{auto$-$increment}, mediante (\textit{integer auto$-$increment}), consentendo di creare dei campi numerici che si auto-incrementano ad ogni nuovo inserimento nella tabella.\vspace*{14pt}\\
\textit{Tipi numerici approssimati}\\I tipi \textbf{numerici approssimati} consentono di rappresentare valori reali con rappresentazione in virgola mobile. SQL fornisce i seguenti tipi:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{float [(Precision)]}
    \item \textit{real}
    \item \textit{doule precision}
\end{itemize}
I domini in questione permettono la rappresentazione di numeri approssimati mediante l'utilizzo di una virgola mobile, suddividendo il numero in una coppia di valori: la mantissa e l'esponente (\textit{0.17E16 --> 1,7$*$10$^{15}$, dove 1,7 indica la mantissa mentre 15 l'esponente}).\vspace*{14pt}\\
\textit{Domini Temporali}\\I \textbf{domini temporali} consentono di rappresentare informazioni temporali, intervalli di tempo o istanti di tempo. SQL-2 mette a disposizione tre diverse forme:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{date}
    \item \textit{time [(Precision)] [with time zone]}
    \item \textit{timestamp [(Precision)] [with time zone]}
\end{itemize} 
Ciascuno di questi domini è strutturato e suddivisibile in un insieme di campi. Come ad esempio \textit{date} ammette i campi \textit{year}, \textit{month} e \textit{day}, il dominio \textit{time} ammette \textit{hour}, \textit{minute} e \textit{second}, infine \textit{timestamp} ammette tutti i campi, da \textit{year} a \textit{second}. Sia per \textit{time} che per \textit{timestamp} è possibile specificare una precisione, che rappresenta il numero di cifre decimali che si devono utilizzare nella rappresentazione delle frazioni di secondo.\vspace*{14pt}\\
\textit{Domini elementari}\\ I \textbf{domini elementari blob} e \textbf{cblob} consentono di rappresentare oggetti di grandi dimensioni come sequenza di valori binari o di caratteri. La \textit{dimensione massima} del file dipende dalla specifiche implementazioni del linguaggio SQL. Tuttavia tramite tale formato non è possibile specificare interrogazioni sui record accomunati da tale attributo.\vspace*{14pt}\\
Tramite il costrutto \textbf{domain} è possibile costruire il proprio \textbf{dominio di dati} a partire dai domini elementari. La sintassi risulta essere cosi descritta:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create domain NameDomain as TypeDate}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=2cm]
    \itemsep0em
    \item \textit{[Default value]}
    \item \textit{[Constraint]}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create domain NameDomain as TypeDate Default (27)}  
\end{itemize}
inoltre rispetto a quanto detto, è possibile specificare un \textbf{valore di default} attraverso il costrutto \textit{default}, ossia:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{default [value | user | null]}
\end{itemize}
\subsection*{Vincoli intra-relazionali}
\large
Sia nella definizione dei domini che delle tabelle, possono essere definiti alcuni vincoli, ovvero delle proprietà che devono essere rispettate da ogni record della base di dati. Il costrutto più potente per specificare vincoli generici, è il costrutto \textit{check}, che richiede di formulare delle interrogazioni alla base di dati.
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{nameAttribute smallint check((attribute >= number1) and (attribute <= number2))}
\end{itemize}
vincolo applicato per ogni \textit{ennupla}. I più semplici vincoli adottabili sono di tipo \textit{intra-relazionale}, quali \textit{not null}, \textit{unique} e \textit{primary key}.\vspace*{14pt}\\
\textit{Not Null}\\Il valore \textit{NULL} è un particolare valore adottato in assenza di informazioni. Tuttavia il vincolo stabilito non ammette il valore \textit{nullo} come valore dell'attributo, quindi il dato dovrà essere sempre specificato, indipendentemente dall'istanza che si voglia inserire. Invece se l'attributo in questione è combinato rispetto ad un valore di \textit{default} diverso dal valore nullo, allora diventa possibile inserire l'istanza anche in assenza di specifica a livello di inserimento. Il vincolo è specificato attribuendo alla definizione dell'attributo la dichiarazione \textit{not null}, come segue:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{nameAttribute varchar(20) not null}
\end{itemize}
\textit{Unique}\\Il vincolo \textit{unique} impone che l'attributo o l'insieme di attributi su cui si applica non possa/possano avere duplicati, ossia stessi valori in istanze differenti, pertanto gli attributi in questione segueno regole definite dal concetto di \textit{superchiave}, per cui essi stessi sono delle superchiavi. Il vincolo può essere espresso in due sintassi, dove la prima delle due descrive:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{nameAttribute Domain [ValDefault] unique}
\end{itemize}
qualora la superchiave della relazione sia un unico attributo, oppure quando è composta da più attributi si adotta solitamente:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{unique(nameAttribute1, nameAttribute2, ...)}
\end{itemize}
concludendo, quest'ultima sintassi è riportata al termine del costrutto per la creazione della tabella. Tuttavia, le due sintassi non hanno la stessa valenza, poichè specificare il vincolo per ogni attributo piuttosto che raggruppare il tutto come la seconda sintassi non persegue nello stesso obiettivo. Infatti, rispettivamente, il primo citato indica che la specifica colonna non possa avere duplicati al suo interno, mentre la definizione \textit{unique(nameAttribute1, nameAttribute2, ...)} indica che l'insieme dei domini riportati per tutte le istanze seguenti non possano avere valori combinati duplicati.\vspace*{14pt}\\
\textit{Primary key}\\Il vincolo \textit{primary key} può essere ugualmente posto come il vincolo \textit{unique}, ma con alcune differenze a livello di implementazione. Tale proprietà ammette che gli attributi associati non possano mai assumere il valore nullo, inoltre l'uso di questo vincolo può avvennire una sola volta, al contrario di unique e not null. In relazione a quanto detto, la sintassi del costrutto è:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create table nameTable(}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=2cm]
    \itemsep0em
    \item \textit{nameAttribute1 Domain [ValDefault]}
    \item \textit{nameAttribute2 Domain [ValDefault]}
    \item \textit{primary key (nameAttribute1, nameAttribute2)}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{);}
\end{itemize}
\subsection*{Vincoli inter-relazionali}
I vincoli inter-relazionali più diffusi sono i \textit{vincoli di integrità referenziale}. In SQL spesso sono denominati come \textit{vincoli} di \textit{foreign key}, ossia di \textit{chiave esterna}. Questa proprietà crea un collegamento tra una tabella \textit{referenziante} e una tabella \textit{referenziata}. Il vincolo impone che ogni riga che compare nella tabella referenziata di un attributo specificato, compaia anche nelle righe della tabella referenziante in un totale di attributi di simile dominio. L'unico requisito imposto richiede che l'attributo o l'insieme di attributi di riferimento, posti internamente alla tabella referenziata, siano soggetti al vincolo \textit{unique}, ovvero sia un identificatore della relazione. Il vincolo può essere posto sia come vincolo \textit{unique} oppure come vincolo \textit{primary key}. Per cui seguono due costrutti di differente sintassi:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create table nameTable1(}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=2cm]
    \itemsep0em
    \item \textit{nameAttribute1 Domain [ValDefault] references nameTable2(nameAttribute1)}
    \item \textit{nameAttribute2 Domain [ValDefault]}
    \item \textit{primary key (nameAttribute1, nameAttribute2)}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{);}
\end{itemize}
dove si osserva la nuova semantica \textit{references} utilizzabile solo quando un singolo attributo risulta essere coinvolto per la costruzione della referenza, mentre qualora sia composta da più di un singolo attributo si adotta:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{create table nameTable1(}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=2cm]
    \itemsep0em
    \item \textit{nameAttribute1 Domain [ValDefault] primary key}
    \item \textit{nameAttribute2 Domain [ValDefault]}
    \item \textit{foreign key (nameAttribute1) references nameTable2(nameAttribute1)}
\end{itemize}
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{);}
\end{itemize}
uso del costrutto \textit{foreign key} per la costruzione è posto sempre al termine della definizione degli attributi, inoltre qualora siano specificati tra le parentesi un numero superiore di attributi per la referenza, SQL segue lo stesso ordine imposto sia per la tabella referenziante e sia per la tabella referenziata.\vspace{14pt}\\
Tuttavia la modifica o l'eliminazione di un valore della tabella referenziante, potrebbe causare l'invalidità del \textit{vincolo di integrità referenziale} per la relazione referenziata. In queste casistiche, spesso si adottano degli strumenti associativi alla tabella referenziata per monitorare violazioni della \textit{foreign key}, gestiti mediante lo stesso costrutto \textit{on}, il quale è definito come:
\begin{itemize} [label={ }, leftmargin=1cm]
    \item \textit{on (delete | update) (cascade | set null | set default | no action)}
\end{itemize}
per cui, tramite la sintassi introdotta, si evince la possibilità di poter manipolare violazioni del vincolo a causa di variazioni sui domini che compongono la \textit{foreign key}. Generalmente, qualora si dovessero verificare azioni di modifica e cancellazione, saranno imposte anche alle colonne che compongano la referenza tra le tabelle in questione.\\
Successivamente alla sintassi \textit{(delete | update)} sono collocati ulteriori strutture intercambiabili, le quali illustrano il comportamento consecutivo all'azione imposta che si ingiunge sui domini interessati.

\subsection*{Data Manipulation Language}
\large
La seconda parte trattata riguarda funzionalità adoperate per modificare e interrogare la base di dati. In una qualsiasi applicazione data, si cerca di emulare le quattro funzionalità CRUD, ossia \textit{create}, \textit{read}, \textit{update} e \textit{delete}. Per rispondere alla necessità dell'\textit{operazioni di lettura}, o meglio definite di \textit{interrogazione}, è utilizzato un singolare costrutto, così attuato:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{Select nameAttribute1, ..., nameAttributeN}
    \item \textit{From nameTable1, ..., nameTableM}
    \item \textit{Where Condition}
\end{itemize} 
a livello di operatività, si effettua il \textit{prodotto cartesiano} delle tabelle prese in considerazione, da cui verranno estratte le \textit{righe} che rispettino la \textit{condizione} posta nell'ultimo blocco sintattico. Di quest'ultime saranno prelevate solo le \textit{colonne} corrispondenti alla selezione posta in primo piano.\vspace*{14pt}\\
Prima di poter distinguere le differenti azioni conseguibili attraverso le \textit{query}, occorre definire al meglio quale sia l'approccio di ogni \textit{blocco sintattico}, con l'obiettivo di illustrare operatori che possano approcciarsi al problema posto dinanzi.\vspace*{14pt}\\
\textit{Select}\\
La clausola \textbf{Select} specifica quali \textit{colonne} debbano essere prese in considerazione per poter produrre il risultato voluto. Per cui, differentemente rispetto a \textit{From} e \textit{Where}, opera solamente a livello di \textit{domini}, senza considerare le \textit{righe} della tabella.
Spesso, tale sintassi, è accomunata da un discreto livello di \textit{ambiguità}; ossia, possono essere prese in considerazioni tabelle che costituiscano il risultato voluto, le cui colonne hanno nominativi simili. Per ovviare a tale problematica, è attuato un certo costrutto definito, \textit{As}. Questo strumento permette di ridenominare i \textit{domini} selezionati dalla \textit{query}, come segue:
\begin{itemize}[label={ }, leftmargin=1cm]
    \item \textit{Select nameAttribute As Name}
\end{itemize} 
\textit{From}\\
La clausola \textbf{From} illustra l'insieme di tabelle che dovranno essere interrogate, pur di ottenere il risultato voluto. La molteplicità di \textit{relazioni} al suo interno permette di descrivere query sempre più avanzate e articolate, adeguandosi rispetto al \textit{prodotto cartesiano}. Come avviene per il costrutto \textit{Select}, è possibile utilizzare \textit{As} affinchè si possano ridenominare le tabelle appartenenti all'insieme di interesse. Ciò avviene per imporre una distinzione referenziale rispetto ai \textit{domini} adoperati.\vspace*{14pt}\\
\textit{Where}\\
La clausola \textbf{Where} indica quali \textit{righe} delle tabelle considerate, debbano comparire nel risultato richiesto. All'interno della \textit{condition} sono poste molteplici espressioni, le quali coinvolgono differenti settori, quali:
\begin{itemize}[label={-}, leftmargin=1cm]
    \itemsep0em
    \item Operatori booelani, come \textit{And}, \textit{Or} e \textit{Not}, dove il loro utilizzo è simile a quanto adottato in linguaggi di programmazione
    \item Operatori di confronto, i quali avvengono tramite il costrutto \textit{Like}, implementato principalmente per comparare variabili di tipo stringa
    \item Operatori di insiemistica, un esempio è dato dallo strumento \textit{Between} che permette, come da denominazione, di verificare se un dato, di tipo numerico, appartenga ad un certo intervallo
\end{itemize}
L'insieme dei termini sintattici da poco descritti, permette la costruzione di \textit{espressisoni regolari}. Un'\textit{espressione regolare} è definita come una sequenza di simboli che identifica univocamente un \textit{insieme di stringhe}.\vspace*{14pt}\\
Una nota di interesse ricade nella considerazione di \textit{valori speciali}, come \textit{NULL}, i quali possono comparire nel blocco sintattico \textit{Where}. Valorizzando una query simile a quanto visto fino ad ora, immetendo il valore \textit{NULL} come se fosse un \textit{dominio elementare}, non permetterebbe la loro inclusione nel risultato finale. Per cui sono implementati operatori designati per questo specifico dato. Si basano sulla \textit{logica a tre fattori}, idealizzata per comprendere \textit{connettori booleani}, distinti in:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Where nameAttribute NOT NULL}
    \item \textit{Where nameAttribute IS NOT NULL}
\end{itemize} 
\textit{Join}\\
Come già accennato, il \textit{costrutto} generale adottato per \textit{interrogare} la base di dati può comprendere un numero crescente di \textit{relazioni}. In certi contesti, pur di poter risalire ad un dato ricercato, occorre combinare valori appartenenti a tabelle differenti. Si riscontra solitamente una sintassi di tale ordine:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select nameAttribute As name}
    \item \textit{From nameTable1, nameTable2}
    \item \textit{Where (primaryKeyTable1 = foreignKeyTable2) And Condition}
\end{itemize} 
E' bene soffermarsi sul processo esecutivo di una query simile, poichè sono presenti passaggi atomici che contraddistinguono la totalità di codice scritto in SQL, i quali possono essere riassunti come di seguito:
\begin{itemize}[label={-}, leftmargin=1cm]
    \itemsep0em
    \item Si effettua il \textit{prodotto cartesiano} delle tabelle, ossia l'insieme delle tuple ordinate appartenenti a tutte le relazioni in questione, generandone una comprendente tutti i domini
    \item Si seleziona l'insieme di righe che abbiano valori comuni e che rispettino la condizione  posta nel costrutto \textit{Where}
    \item Si seleziona il dominio specificato inizialmente nel primo costrutto sintattico
    \item Concludendo, stabiliti i passaggi, si articolano fra loro pur di ottenere il risultato finale 
\end{itemize}
\textit{Notazioni aggiuntive}\\
Una query in genere, se non imposto, non attua filtri a livello di ricerca. Per cui la costruzione di un'interrogazione potrebbe produrre come risultato finale una moltitudine di \textit{rows duplicate}, le quali non favoriscono quanto richiesto. Una soluzione prevede l'uso di costrutti specifici, articolati nella prima parte sintattica del codice SQL. I quali, brevemente, sono posti come segue:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select distinct(nameAttribute1), ..., nameAttributeN}
\end{itemize}
ciò consente di rimuovere tutti i duplicati, che abbiano medesima valorizzazione rispetto ai domini presi in considerazione, all'interno del risultato.\vspace*{14pt}\\
Dato un approccio che mitiga su un certo rigore, un'altra espressione che opera sullo stesso layer è data da:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Where condition}
    \item \textit{Order by nameAttribute1, ..., nameAttributeN}
\end{itemize}
\textit{Order by} permette di imporre un criterio d'ordine rispetto agli attributi che formulano i domini selezionati; si evince che la massima utilità del costrutto avviene qualora le colonne interessate siano \textit{domini elementari} di carattere \textit{numerico}.\vspace*{7pt}\\
\textbf{Esempi particolari}\\
...

\subsection*{Operatori}
\large
\textit{Operatori aggregati}\\
Gli \textbf{operatori aggregati} sono costrutti applicati ad insiemi di \textit{tuple} e producono un unico risultato. SQL impone che siano inseriti all'interno della sintassi della \textit{Select}, per cui valutati dopo aver applicato le clausola del \textit{Where} e del \textit{From}.\vspace*{14pt}\\
Sono adoperati differenti tipologie di \textit{esecutori}, i quali si suddividono in:\\
\textbf{Trovare qualcosa sul libro ...}
\begin{itemize}[label={-}, leftmargin=1cm]
    \itemsep0em
    \item \textit{Count}, permette di contare il numero di righe della relazione ottenuta, mediante non solo alla selezione dei domini, ma anche in relazione alla condizione verificata e alle tabelle che compongano il prodotto cartesiano
    \item \textit{Max}, restituisce il massimo della colonna selezionata
    \item \textit{Sum}, restituisce la somma della colonna selezionata
    \item \textit{Min}, restituisce il minimo della colonna selezionata
    \item \textit{Avg}, restituisce la media della colonna selezionata
\end{itemize}
Tra gli esecutori elencati vige una diversificazione rispetto al loro utilizzo all'interno della clausola primaria. Tuttavia, la sintassi generale per poter usufruire delle caratteristiche descritte risulta:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select Operation(nameAttribute)}
    \item \textit{From nameTable}
    \item \textit{Where Condition}
\end{itemize}
Posta la sintassi generale, la diversificazione si nota dalla costruzione dell'interrogazione, dove si illustrano due tematiche principali:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select Count(* | nameAttribute | nameAttribute1, ..., nameAttributeN)}
    \item \textit{From nameTable}
    \item \textit{Where Condition}
    \item 
    \item \textit{Select Avg(nameAttribute)}
    \item \textit{From nameTable}
    \item \textit{Where Condition}
\end{itemize} 
da cui si nota che la caratteristica fondamentale che non eguaglia le due entità avviene all'interno della clausola \textit{Select}. Infatti l'operatore \textit{Count} garantisce un'esecuzione su insieme di possibili domini, si noti la presenza del carattere speciale (*); mentre esecutori come \textit{Avg} sono adottati nei confronti di una singola colonna. E' bene sottolineare come questa sottile discrepanza non incida sul processo esecutivo delle query introdotto e illustrato fino ad ora.\vspace*{14pt}\\
Anche in questo caso è bene soffermarsi sul processo esecutivo che caratterizza query simili:
\begin{itemize}[label={-}]
    \itemsep0em
    \item Si considerano tutte le tabelle selezionate dalla clausola \textit{From}, prestando attenzione a rimuovere ogni ambiguità
    \item Si effettua il \textit{prodotto cartesiano} delle relazioni, generandone una comprendente tutti i domini del caso
    \item Si seleziona l'insieme di righe che rispettino la condizione del costrutto \textit{Where}
    \item Si considerano i domini posti all'interno della \textit{Select}, a cui si applica l'\textit{operatore aggregato} sulla colonna richiesta
    \item Concludendo, stabiliti i passaggi, si articolano fra loro ottenendo una relazione comprendente una sola colonna e riga
\end{itemize}
\textit{Group by}\\
Un \textit{operatore aggregato} restituisce un solo valore, come indicato dal processo esecutivo. Tuttavia, in alcuni contesti, potrebbe essere richiesto di formulare espressioni che riescano a combinare \textit{esecutori} rispetto ad un numero crescente di \textit{record}. Ciò è garantito da un costrutto specializzato, il quale accorda l'univocità degli operatori aggregati rispetto alla selezione multipla della \textit{Select}.\vspace*{14pt}\\
Per aggregare i due approcci, si adottano \textbf{operatori di raggruppamento}, che consentono di dividere la tabella in \textit{gruppi}, ognuna caratterizzata da un valore comune dell'attributo specificato nell'operatore. La sintassi si dimostra come segue:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select nameAttribute1, ..., nameAttributeN}
    \item \textit{From nameTable1, ..., nameTableM}
    \item \textit{Where Condition}
    \item \textit{Group by nameAttribute1, ..., nameAttributeM}
\end{itemize}
una nota di interesse avviene nei confronti delle liste attuate nei construtti \textit{Select} e \textit{Group by}, in cui i domini della prima sintassi devono essere un sottoinsieme dei domini dell'\textit{operatore di aggregazione}, poichè un \textit{gruppo} produce una singola riga nel risultato finale. \textbf{Trovare spiegazione più esaustiva}.\vspace*{14pt}\\
\textit{Having}\\
La sintassi \textbf{Having} permette di applicare un \textit{filtro di ricerca} rispetto all'aggregazione precedente del costrutto \textit{Group by}. L'\textit{operatore di ricerca} è posto al termine delle query, da cui ne deriva:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select nameAttribute1, ..., nameAttributeN}
    \item \textit{From nameTable1, ..., nameTableM}
    \item \textit{Where Condition}
    \item \textit{Group by nameAttribute1, ..., nameAttributeM}
    \item \textit{Having Condition}
\end{itemize}
dove ciò che differenzia l'ultima condizione posta, rispetto alla precedente, consiste sull'entità su cui è applicata. \textit{Where} valuta per ogni \textit{row} che sia parte della selezione dei domini, mentre \textit{Having} è valutata su ogni gruppo, per cui non restituisce singoli elementi ma un insieme oppure un sottoinsieme di elementi.\vspace*{14pt}\\
Nuovamente, il processo esecutivo subisce delle modifiche rispetto ai nuovi costrutti introdotti:
\begin{itemize}[label={-}]
    \itemsep0em
    \item Si effettua il \textit{prodotto cartesiano} delle tabelle, generandone una comprendente tutti i domini del caso
    \item Si estraggono l'insieme di righe che rispettino la condizione del costrutto \textit{Where}
    \item Avviene il partizionamento della tabella, rispetto alla funzionalità imposte
    \item Si selezionano i gruppi, i quali sono rappresentativi di sottoinsiemi di interesse
    \item Si estraggono i domini della selezione, a cui saranno successivi gli \textit{operatori aggregati} sui gruppi modellati, componendo il risultato richiesto
\end{itemize}
\textit{Operatori insiemistici}\\
SQL mette a disposizione, oltre ad \textit{operatori aggregati} e \textit{operatori di raggruppamento}, esecutori affini alla logica insiemistica. Gli \textbf{operatori insiemistici} sono adoperati affinchè attività basilari appartenenti alla teoria degli insiemi, possano essere utilizzate anche tra colonne di differenti tabelle. Le operazioni effettuabili, immesse all'interno della clausola \textit{Select}, sono: 
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Union}, come da denominazione rappresenta l'unione di domini, rispetto alla totalità di tabelle prese in considerazione dalla clausola \textit{From}
    \item \textit{Intersect}, rappresentativa dell'\textit{intersezione}, per cui il risultato consiste in tutte quelle colonne che abbiano valori comuni
    \item \textit{Except}, individua l'\textit{eccezione}, ossia la sottrazione tra insiemi
\end{itemize}
\textbf{Esempi particolari}\\
...

\subsection*{Join}
\large
Fino ad ora l'operatore \textit{join}, il quale permette di ricavare una tabella comprendente un insieme di domini appartenenti a relazioni differenti fra loro, è stato utilizzato all'interno della clausola \textit{Where} affinchè sia rispettata la condizione del \textit{vincolo inter-relazionale}. Tuttavia spesso si fa uso di un'ulteriore metodologia, del tutto equivalente rispetto a quella descritta precedentemente. Si tratta dell'esecutore \textbf{Inner Join}, manifestato all'interno della clausola \textit{From}. La sintassi esplicativa è definita come segue:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select nameAttribute}
    \item \textit{From nameTable1 Join nameTable2 On primaryKeyTable1 = foreignKeyTable2}
    \item \textit{Where Condition}
\end{itemize} 
Si osserva quale sia la differenza principale che contraddistingue le due sintassi, ossia l'unione delle relazioni interessate è anticipata rispetto alla corrisposta. Nell'esempio sono riportate le colonne che costituiscano il \textit{vincolo inter-relazionale}, le quali sono indicativamente di denominazione differente, tuttavia per ovviare ad ambiguità è obbligatorio formulare il costrutto \textit{nameTable.nameAttribute}.\vspace*{14pt}\\
Concludendo esistono tre varianti dell'operatore, anche se poco utilizzate, le quali approcciano ad unioni di tabelle in maniera singolare. Brevemente esse sono suddivise in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Left Join}, pone il risultato dell'\textit{Inner Join} in combinazione con le righe della \textit{tabella di sinistra}, che non hanno un corrispettivo a destra
    \item \textit{Right Join}, pone il risultato dell'\textit{Inner Join} in combinazione con le righe della \textit{tabella di destra}, che non hanno un corrispettivo a sinistra
    \item \textit{Full Join}, pone il risultato dell'\textit{Inner Join} in combinazione con le righe della \textit{tabella di sinistra/destra}, che non hanno un corrispettivo
\end{itemize}
\textbf{Esempi particolari}\\
... 

\subsection*{Query annidate}
\large
Le query illustrate rappresentano un livello di complessità piuttosto basilare, in grado di rispondere ad un breve insieme di interrogazioni alla base di dati. Tramite la clausola del \textit{Where} possono essere articolate \textit{espressioni complesse}, in cui valori appartenenti a domini sono confrontati con il risultato derivato da un'ulteriore \textbf{query annidata}.\\
La sintassi adeguata risulta:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Select nameAttribute}
    \item \textit{From nameTable}
    \item \textit{Where Condition (Select ... From ... Where ...)}
\end{itemize}
Il costrutto indica due \textit{query annidate}, in cui insiemi o singoli valori possono essere confrontati con una \textit{query interna}, la quale potenzialmente potrebbe consistere in una relazione.\vspace*{14pt}\\
Una \textit{query annidata} si suddivide in due entità, dove l'interrogazione compresa nella clausola \textit{Where} è definita \textbf{query interna} mentre quella posta esternamente è chiamata \textbf{query esterna}. Come citato poco fa, la \textit{query interna} è in grado di restituire singoli elementi oppure insiemi di elementi. In caso si dovesse verificare la seconda effettività, non sarebbe possibile utilizzare \textit{operatori di confronto} adoperati sino a ora. Per ovviare alla problematica, SQL mette a disposizione \textbf{operatori speciali di confronto}, i quali coinvolgono medesimi meccanismi di funzionamento di operatori basilari, distinti in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{All}, restituisce il risultato voluto se e solo se il confronto tra il valore del dominio e \textit{tutti} i valori della query interna soddisfino la condizione
    \item \textit{Any}, restituisce il risultato voluto se e solo se il confronto tra il valore del dominio e \textit{almeno} uno dei valori della query interna soddisfino la condizione
    \item \textit{Exists}, restituisce il risultato voluto se e solo se il confronto della query annidata fornisce un \textit{insieme non vuoto}, comprendente almeno un valore
    \item \textit{In}, restituisce il risultato voluto se e solo se un \textit{certo valore} è contenuto nel risultato della query interna
\end{itemize}
Terminando, in relazione a \textit{query annidate}, solitamente si suddividono due aree, le quali sono caratterizzate da riferimenti interni ed esterni tra le query che compongono l'interrogazione.\vspace*{14pt}\\
\textit{Definizione informale}\\
Una query annidata è detta \textbf{semplice} se non avviene passaggio di binding, dove la query più interna viene valutata con ciascuna riga della tabella esterna, ossia non è presente alcuna dipendenza fra le due.\vspace*{14pt}\\
\textit{Definizione informale}\\
Una query annidata è detta \textbf{complessa} se avviene passaggio di binding, dove le interrogazioni interne vengono valutate su ogni tupla. \textbf{Trovare migliore definizione}

\subsection*{Viste}
\large
Le \textbf{viste} sono tabelle \textit{virtuali}, formulate mediante dati contenuti in ulteriori relazioni della base di dati. Ogni \textit{vista} ha una propria denominazione e un insieme di domini che la contraddistingue, ottenuta mediante un costrutto sintattico particolare, quale:
\begin{itemize}[label={ }, leftmargin=1cm]
    \itemsep0em
    \item \textit{Create view nameView (nameAttribute1, ..., nameAttributeN)}
    \item \textit{As SelectSQL} 
    \item \textit{...} 
\end{itemize}
I valori che compongono una \textit{vista} non sono memorizzati fisicamente, poichè dipendono da altre relazioni, per cui la costruzione avviene solamente in memoria volatile. Spesso il costrutto introdotto è utilizzato qualora una richiesta specifica non possa essere formulata mediante \textit{query annidate}, la quale richieda l'utilizzo di \textit{operatori aggregati} e costrutti di selezione articolati.\vspace*{14pt}\\
Sono attuate differenti realtà in cui si adoperano le \textit{tabelle virtuali}, suddivise in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item Implementazione di meccanismi di indipendenza tra il livello logico e il livello esterno
    \item Garantire la retrocompatibilità con precedenti versioni del database
    \item Realizzare interrogazioni complesse, semplificandone la sintassi
\end{itemize}
\textbf{Esempi particolari}\\
...

\subsection*{Costrutti avanzati}
\large
Fino ad ora sono stati trattati costrutti basilari, caratteristici della versione del linguaggio SQL2. Tuttavia, la versione successiva a quella citata precedentemente, ossia SQL3, mette a disposizione i \textbf{costrutti avanzati}, fortemente dipendenti dal \textit{Data-Base-Management-System} adoperato.\vspace*{14pt}\\
\textit{Definizione informale}\\
Le \textbf{procedure} sono frammenti di codice SQL, molto simili al comportamento esecutivo di funzioni in un linguaggio di programmazione. Al loro interno è possibile illustrare un nominativo, parametri di ingresso e valori di ritorno.\vspace*{14pt}\\
\textit{Definizione informale}\\
Un \textbf{trigger} è un meccanismo di gestione della base di dati, basato sul paradigma \textit{ECA}, acronimo di evento, condizione e azione.\vspace*{14pt}\\
\textit{Definizione informale}\\
Un \textbf{permesso} è un meccanismo di controllo di accesso alle risorse mantenute dallo schema della base di dati. Su ogni risorsa sono stabiliti dei \textbf{privilegi}, i quali permettono di compiere le tipiche operazioni di accesso, lettura, modifica oppure di eliminazione.
\end{document}